			uint8_t bytes[2], bytes2[4];
			float result;
			float f;
			// Convert over to 2 BYTES
			half = floatToHalf(f);
			bytes[0] = half & 0x0F;
			bytes[1] = (half >> 8) & 0x0F;
			// Convert back
			result = halfToFloat((uint16_t)((bytes[1] << 8) & bytes[0]));
			// Convert over to FOUR BYTES
			temp = *((uint32_t*)&f);
			bytes2[0] = temp[0] & 0x0F;
			bytes2[1] = (temp[0] >> 8) & 0x0F;
			bytes2[2] = (temp[0] >> 16) & 0x0F;
			bytes2[3] = (temp[0] >> 24) & 0x0F;
			// convert back
			temp = (bytes2[3] << 24) & (bytes2[2] << 16) & (bytes2[1] << 8) & bytes2[0];
			result = *((float*)&temp);


//conversion stuff

/*
Processor Version

Remember, it can send requests for state data and configuration parameters.

*/
	
/*
Hardware Version

Remember, it can send responses to requests for state info and processor interrupts.

Choose Node Value
Add Interrupts
*/

/*
GPS Transmitter

Set Node
Set Priority
Add Connection to GPS Data
*/

	
/*
Processor Transmissions

HW Transmits
*/

/*
Default Send Wait Model
*/

while(!canif->can_transmit()) //set priority
{
	target = canif->can_listen(msgType, message, length, transfer, source);
}
canif->// whatever you want to broadcast/send

private:
	unsigned char transfer, source, target, length, priority;
	unsigned short msgType;
	unsigned char message[7];

	// Temporary pilot command generation thread
	void FlightController::mainPilot() {
		// Initialization
		cmd.enableAttPID = true;
		cmd.enablePosPID = true;

		// Flight sequence
		cout << "[" << sc_time_stamp() << "] Targeting altitude of 15m, yaw rate of 5deg/s" << endl;
		posCmd[ZAXIS] = 15;
		attCmd[YAW] = 45*M_PI/180;
		wait(5000, SC_MS);

		cout << "[" << sc_time_stamp() << "] Dropping altitude to 4m" << endl;
		posCmd[ZAXIS] = 4;
	}
